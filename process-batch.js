#!/usr/bin/env node

const Database = require('better-sqlite3');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

async function processBatch() {
    console.log("ðŸš€ Processing batch of 10 unbroadcasted documents...\n");
    
    // Connect to database
    const db = new Database('./agent/data/db.sqlite');
    
    // Get 10 unbroadcasted documents  
    const docs = db.prepare(`
        SELECT m.* 
        FROM memories m
        WHERE m.type = 'documents'
        AND m.id NOT IN (SELECT DISTINCT documentId FROM broadcasts WHERE documentId IS NOT NULL)
        AND json_extract(m.content, '$.text') IS NOT NULL
        AND length(json_extract(m.content, '$.text')) > 100
        ORDER BY m.createdAt DESC
        LIMIT 10
    `).all();
    
    console.log(`Found ${docs.length} documents to process\n`);
    
    // Load character
    const characterPath = path.join(__dirname, 'characters/ai10bro.character.json');
    const character = JSON.parse(fs.readFileSync(characterPath, 'utf-8'));
    
    // Process each document
    let created = 0;
    let skipped = 0;
    const results = [];
    
    for (const doc of docs) {
        const content = JSON.parse(doc.content);
        const text = content.text || '';
        
        // Extract title
        const titleMatch = text.match(/title:\s*"?([^"\n]+)"?/i);
        const title = titleMatch ? titleMatch[1].trim() : text.substring(0, 50) + '...';
        
        console.log(`\nðŸ“„ Processing: ${title}`);
        console.log(`   ID: ${doc.id}`);
        
        // Clean text
        const cleanedText = text.replace(/\*[^*]+\*/g, '').replace(/\s+/g, ' ').trim();
        
        // Skip test/draft documents
        if (/test|draft|cache/i.test(title)) {
            console.log(`   â­ï¸  Skipped (unwanted title)`);
            skipped++;
            continue;
        }
        
        // For this test, we'll simulate alignment scores based on keywords
        // (since we can't call the actual embed function without the runtime)
        let alignmentScore = 0.5; // base score
        
        // Check for alignment keywords
        const alignmentKeywords = [
            'climate', 'sustainable', 'regenerative', 'biomimetic', 'nature',
            'ecosystem', 'carbon', 'renewable', 'circular', 'resilience',
            'CRISPR', 'gene', 'synthetic biology', 'microbe', 'bacteria',
            'AI', 'machine learning', 'neural', 'convergence', 'evolution'
        ];
        
        alignmentKeywords.forEach(keyword => {
            if (cleanedText.toLowerCase().includes(keyword)) {
                alignmentScore += 0.05;
            }
        });
        
        alignmentScore = Math.min(alignmentScore, 1.0);
        
        console.log(`   Alignment: ${alignmentScore.toFixed(3)} (simulated)`);
        
        if (alignmentScore < 0.6) {
            console.log(`   â­ï¸  Skipped (low alignment)`);
            skipped++;
            continue;
        }
        
        // Extract source URL
        const sourceMatch = text.match(/source:\s*(https?:\/\/[^\s]+)/i);
        const sourceUrl = sourceMatch ? sourceMatch[1] : null;
        
        // Generate a preview broadcast message
        // (In production this would use the actual LLM)
        const preview = cleanedText.substring(0, 300);
        let finalText = `[Preview - would be generated by LLM]\n${preview}...`;
        
        if (sourceUrl) {
            finalText = `${finalText}\n\nðŸ”— Source: ${sourceUrl}`;
        }
        
        // Store broadcast
        const broadcastId = crypto.randomUUID();
        db.prepare(`
            INSERT INTO broadcasts (
                id, documentId, client, content, 
                status, alignment_score, createdAt
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
        `).run(
            broadcastId,
            doc.id,
            'telegram',
            finalText,
            'pending',
            alignmentScore,
            Date.now()
        );
        
        console.log(`   âœ… Created broadcast ${broadcastId}`);
        console.log(`   Preview: "${finalText.substring(0, 150)}..."`);
        
        results.push({
            title,
            alignmentScore,
            broadcastId,
            content: finalText,
            documentId: doc.id
        });
        
        created++;
    }
    
    // Summary
    console.log("\n" + "=".repeat(80));
    console.log("ðŸ“Š SUMMARY");
    console.log("=".repeat(80));
    console.log(`âœ… Created: ${created} broadcasts`);
    console.log(`â­ï¸  Skipped: ${skipped} documents`);
    
    if (results.length > 0) {
        console.log("\nðŸ“¢ GENERATED BROADCASTS:");
        console.log("-".repeat(80));
        
        results.forEach((r, i) => {
            console.log(`\n${i + 1}. ${r.title}`);
            console.log(`   Alignment: ${r.alignmentScore.toFixed(3)}`);
            console.log(`   Document ID: ${r.documentId}`);
            console.log(`   Length: ${r.content.length} chars`);
            console.log(`   Message:\n   "${r.content}"\n`);
        });
    }
    
    // Show actual content of top 3 documents for manual review
    if (results.length > 0) {
        console.log("\n" + "=".repeat(80));
        console.log("ðŸ“ TOP 3 DOCUMENTS FOR MANUAL BROADCAST CREATION:");
        console.log("=".repeat(80));
        
        results.slice(0, 3).forEach((r, i) => {
            const doc = db.prepare('SELECT * FROM memories WHERE id = ?').get(r.documentId);
            const content = JSON.parse(doc.content);
            const text = content.text || '';
            
            console.log(`\n${i + 1}. ${r.title}`);
            console.log("-".repeat(40));
            console.log(text.substring(0, 500) + "...\n");
        });
    }
    
    db.close();
    console.log("\nâœ¨ Batch processing complete!");
}

processBatch().catch(console.error);