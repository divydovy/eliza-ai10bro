#!/usr/bin/env node

/**
 * Generate GitHub issues from quality check results
 * Reads the latest quality report and creates issues for high-priority problems
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function generateIssueBody(issue, check) {
    const severity = issue.severity === 'high' ? 'üö® Critical' : issue.severity === 'medium' ? '‚ö†Ô∏è Medium' : 'üí° Low';

    let body = `## ${severity} Priority

**Check**: ${check.name}
**Detected**: ${new Date().toISOString().split('T')[0]}

### Problem
${issue.message}

`;

    // Add samples if available
    if (issue.samples && issue.samples.length > 0) {
        body += `### Examples\n\n`;
        issue.samples.forEach((sample, i) => {
            body += `${i + 1}. `;
            Object.entries(sample).forEach(([key, value]) => {
                body += `**${key}**: \`${value}\` `;
            });
            body += `\n`;
        });
        body += `\n`;
    }

    // Add recommendation
    if (issue.recommendation) {
        body += `### Recommended Fix\n${issue.recommendation}\n\n`;
    }

    // Add metrics if available
    if (check.metrics) {
        body += `### Metrics\n\`\`\`json\n${JSON.stringify(check.metrics, null, 2)}\n\`\`\`\n\n`;
    }

    body += `---\n_Auto-generated by quality-checks/run-quality-checks.js_`;

    return body;
}

function getIssueLabels(issue) {
    const labels = ['quality-check'];

    if (issue.severity === 'high') labels.push('priority-high');
    if (issue.severity === 'medium') labels.push('priority-medium');

    if (issue.type.includes('url')) labels.push('bug', 'urls');
    if (issue.type.includes('image')) labels.push('enhancement', 'images');
    if (issue.type.includes('content')) labels.push('bug', 'content');
    if (issue.type.includes('scoring')) labels.push('enhancement', 'scoring');

    return labels;
}

async function main() {
    // Find latest quality report
    const reportsDir = path.join(process.cwd(), 'logs/quality');
    const files = fs.readdirSync(reportsDir)
        .filter(f => f.startsWith('quality-report-'))
        .sort()
        .reverse();

    if (files.length === 0) {
        console.log('‚ùå No quality reports found');
        process.exit(1);
    }

    const latestReport = path.join(reportsDir, files[0]);
    console.log(`üìÑ Reading: ${latestReport}\n`);

    const report = JSON.parse(fs.readFileSync(latestReport, 'utf8'));

    // Collect issues by priority
    const highPriority = [];
    const mediumPriority = [];

    report.checks.forEach(check => {
        check.issues.forEach(issue => {
            const issueData = {
                check: check.name,
                issue,
                title: `[Quality] ${issue.message.split('\n')[0]}`,
                body: generateIssueBody(issue, check),
                labels: getIssueLabels(issue)
            };

            if (issue.severity === 'high') {
                highPriority.push(issueData);
            } else if (issue.severity === 'medium') {
                mediumPriority.push(issueData);
            }
        });
    });

    console.log(`Found ${highPriority.length} high priority issues`);
    console.log(`Found ${mediumPriority.length} medium priority issues\n`);

    // Generate issue commands
    const issuesToCreate = [...highPriority, ...mediumPriority.slice(0, 3)]; // Limit to top 3 medium

    if (issuesToCreate.length === 0) {
        console.log('‚úÖ No issues to create - all checks passed!');
        process.exit(0);
    }

    console.log('GitHub issue creation commands:\n');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

    issuesToCreate.forEach((issueData, i) => {
        console.log(`# Issue ${i + 1}: ${issueData.title}`);
        console.log(`gh issue create \\`);
        console.log(`  --title "${issueData.title}" \\`);
        console.log(`  --body "${issueData.body.replace(/"/g, '\\"')}" \\`);
        console.log(`  --label "${issueData.labels.join(',')}"\n`);
    });

    // Save to file for manual execution
    const scriptPath = path.join(process.cwd(), 'logs/quality/create-issues.sh');
    let script = '#!/bin/bash\n\n# Auto-generated GitHub issue creation script\n# Review before executing!\n\n';

    issuesToCreate.forEach((issueData, i) => {
        script += `echo "Creating issue ${i + 1}/${issuesToCreate.length}..."\n`;
        script += `gh issue create \\\n`;
        script += `  --title "${issueData.title}" \\\n`;
        script += `  --body "${issueData.body.replace(/"/g, '\\"').replace(/\n/g, '\\n')}" \\\n`;
        script += `  --label "${issueData.labels.join(',')}"\n\n`;
    });

    fs.writeFileSync(scriptPath, script);
    fs.chmodSync(scriptPath, '755');

    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
    console.log(`üíæ Script saved to: ${scriptPath}`);
    console.log(`\nTo create issues, run: ${scriptPath}\n`);
}

main().catch(error => {
    console.error('‚ùå Error:', error);
    process.exit(1);
});
